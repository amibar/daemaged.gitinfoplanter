{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","tagline":"Plant Git Information into .NET Assemblies","body":"# Plant git repo information in .NET assemblies #\r\n\r\ngitinfoplanter.exe automates the process of reading your git repo status and embedding it as an easy to use string in an assembly level attribute of your .NET executable.\r\n\r\n## Git Repo String ##\r\n\r\nSo how does a version string look?  \r\nThe best way to answer this is to simply run the info planter with --version to see a sample:\r\n\r\n> $ ./daemaged.gitinfoplanter.exe --version  \r\n> daemaged.gitinfoplanter version \"1.1.0.0.4658/1.1/20/1e5356fd2bdbde4b5c82552844e6eb5ed6d5a9f2\"\r\n\r\nThe version string is the part that says: *1.1.0.0.4658/1.1/20/1e5356fd2bdbde4b5c82552844e6eb5ed6d5a9f2*  \r\nbut what does it really mean?\r\n<img src=\"https://raw.github.com/damageboy/daemaged.gitinfoplanter/master/version-info-explanation.svg\" height=\"258\" width=\"750\" />\r\n\r\n- The first part, 1.1.0.0.4658 in this case, is really composed of two parts\r\n - The Assembly Version attribute value (This is the normal value that get included in every .NET AssemblyInfo.cs file, 1.0.0.0 in this case\r\n - The build-day, expressed as number of days since a specified \"epoch-day\", 1/1/2000 by default, 4658 days in this case, any base date is really good here, as long as it's constant..., good options are your anniversary, birthday, child's birth-day, historical event or whatever :)\r\n- The second part is best described as the \"what-to-checkout or clone\" field... Normally it will be the branch name of the build, **but it doesn't have to be**: if the build was made of a *valid* tag release, it will contain the name of the tag... What makes a valid tag release?\r\n  - The commit has to have a tag (duh)\r\n  - The tag has to be pushed\r\n  - There are no local modifications\r\n  - The same commit is also pushed to the origin\r\n- Next we have the revision # which can be thought of as some incremental number that provides an SVN-esque revision #. In reality it's just a count of the commits in the current branch...  \r\nHowever, this revision # may have appendages:\r\n  - +N in case the local commit is ahead of the origin, and N denoted by how many local commits\r\n  - The string \"M\" in case the build was done off of a repo with local modifications\r\n - Last but not least, the full commit hash is embedded as a string, for safe keeping\r\n\r\n## Where/How does this get embedded? ##\r\nThe git info planter uses cecil to re-write the assembly and embed two assembly level attributes:\r\n\r\n- `[AssemblyFileVersionAttribute]` will be embedded with the first part of the full string as it's value (1.1.0.0.4658 in the previous example)\r\n- `[AssemblyInformationalVersionAttribute]` will be embedded with the full string as it's value\r\n\r\nSo, you can think of the resulting assemblly *as-if* someone went back to your code, and edited you AssemblyInfo.cs file from this:\r\n\r\n```c#\r\nusing System.Reflection;\r\n\r\n[assembly: AssemblyTitle(\"Daemaged.GitInfoPlanter\")]\r\n[assembly: AssemblyDescription(\"Plant git information into .NET assemblies\")]\r\n[assembly: AssemblyCompany(\"Damage INC.\")]\r\n[assembly: AssemblyProduct(\"Daemaged.GitInfoPlanter\")]\r\n[assembly: AssemblyCopyright(\"Copyright (C) Dan Shechter, Inc. 2010\")]\r\n[assembly: AssemblyVersion(\"1.1.0.0\")]\r\n```\r\n\r\nTo this:\r\n```c#\r\nusing System.Reflection;\r\n\r\n[assembly: AssemblyTitle(\"Daemaged.GitInfoPlanter\")]\r\n[assembly: AssemblyDescription(\"Plant git information into .NET assemblies\")]\r\n[assembly: AssemblyCompany(\"Damage INC.\")]\r\n[assembly: AssemblyProduct(\"Daemaged.GitInfoPlanter\")]\r\n[assembly: AssemblyCopyright(\"Copyright (C) Dan Shechter, Inc. 2010\")]\r\n[assembly: AssemblyVersion(\"1.1.0.0\")]\r\n[assembly: AssemblyFileVersionAttribute(\"1.1.0.0.4658\")]\r\n[assembly: AssemblyInformationalVersionAttribute(\"1.1.0.0.4658/1.1/20/1e5356fd2bdbde4b5c82552844e6eb5ed6d5a9f2\")]\r\n```\r\n\r\nOf course, no real changes to the code were actually made, however the resulting binary will contain the additional attributes\r\n\r\n## How do I retrieve these attributes at runtime? ##\r\n\r\nWell, it's obviously a very idea to be able to actually read these things when displaying an about dialog, or when a `--version` option is perhaps specified of command-line...  \r\nIt's a very simple chore to accomplish, in c# for example, all that one needs to do is:\r\n```c#\r\nvar versionInfo = \r\n  asm.GetCustomAttributes(typeof(AssemblyInformationalVersionAttribute), false)\r\n     .Cast<AssemblyInformationalVersionAttribute>().FirstOrDefault();\r\nvar versionString = \r\n  versionInfo == null ? \r\n   \"No specific version info embedded\" : \r\n   versionInfo.InformationalVersion;\r\nConsole.WriteLine(\"MyProduct - {0}\", versionString);\r\n```\r\n\r\n## OK, I'm sold, how do I put this in my build process? ##\r\nOK, so that is perhaps a slightly weak side of this project... it's integration level with IDE etc.\r\nThe best way would be to simply add it as an after build step in Visual Studio / MonoDevelop / MSBuild.\r\n\r\nThe way I personally do it is by manually editing the .csproj and adding an `<AfterBuild>` target","name":"Daemaged.gitinfoplanter"}